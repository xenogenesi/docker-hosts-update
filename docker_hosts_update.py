import logging
import click
import docker
import sys
from typing import Dict, List
import click_log
import subprocess
import os
import shlex

logger = logging.getLogger(__name__)
click_log.basic_config(logger)

HOSTS_FILE_START_MARKER = "# ! docker-hosts-update start !"
HOSTS_FILE_END_MARKER = "# ! docker-hosts-update end   !\n"


def map_hosts() -> Dict[str, List[str]]:
    """Returns dictionary"""
    client = docker.from_env()
    networks = client.networks.list()
    host_map = dict()
    for network in networks:
        network.reload()
        for _, value in network.attrs['Containers'].items():
            ip_without_mask = value['IPv4Address'][:value['IPv4Address'].index('/')]
            hostname = f'{value["Name"]}.{network.name}'
            if hostname not in host_map:
                host_map[hostname] = []
            host_map[hostname].append(ip_without_mask)
    return host_map


def update_hosts_file(filename: str, with_command = None, trigger_type=None, trigger_status=None, event: dict=None):
    host_map = map_hosts()
    lines = []
    for hostname, ips in host_map.items():
         for ip in ips:
            lines.append(f'{ip}   {hostname}')
            
    content = "\n".join(lines)
    hosts_file_section = f"""{HOSTS_FILE_START_MARKER}
# This section was automatically generated by docker-hosts-update
# Don't edit this part manually :)
{content}
{HOSTS_FILE_END_MARKER}"""
    try:
        with open(filename, 'r') as hostsfile:
            original_host_file = hostsfile.read()
    except PermissionError:
        logging.error(f'Did not have permission to read {filename}.')
        return False

    start = original_host_file.find(HOSTS_FILE_START_MARKER)
    end = original_host_file.find(HOSTS_FILE_END_MARKER) + len(HOSTS_FILE_END_MARKER) 
    if start > -1 and end > -1:
        logging.debug('Found previously generated section, will attempt to replace.')
        new_host_file = original_host_file[:start] + hosts_file_section + \
        original_host_file[end:]
    else:
        logger.debug('Found no previously generated section, will append.')
        new_host_file = original_host_file + hosts_file_section

    # with-command
    if with_command != None:
        cmd_env = os.environ.copy()
        if trigger_status != None:
            cmd_env["TRIGGER_STATUS"] = trigger_status
        if trigger_type != None:
            cmd_env["TRIGGER_TYPE"] = trigger_type

        if event != None:
            #cmd_env = {}
            _dict2env(cmd_env, 'EVENT', event)
            #cmd_env.update(event_env)

        cmd = subprocess.Popen(shlex.split(with_command), stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, close_fds=True, text=True, env=cmd_env)
        cmd_stdout, cmd_stderr = cmd.communicate(input=new_host_file)
        cmd.wait()
        if cmd.returncode == 0:
            new_host_file = cmd_stdout
        else:
            print("return code != 0")
    # ~with-command

    try: 
        with open(filename, 'w') as hostsfile:
            original_host_file = hostsfile.write(new_host_file)
            logger.info(f'Wrote new {filename}')
    except PermissionError:
        logger.error(f'Did not have permission to write to {filename}.')
        return False
    
    return True


# Events that trigger the host file being updated.
TRIGGERING_DOCKER_EVENTS = [
    {'status': 'start', 'Type': 'container'},
    {'status': 'stop', 'Type': 'container'},
    {'status': 'die', 'Type': 'container'},
    {'status': 'destroy', 'Type': 'container'},
]


def _triggering_event(event: dict):
    for trigger in TRIGGERING_DOCKER_EVENTS:
        if all(event.get(key) == val for key, val in trigger.items()):
            return trigger

def _dict2env(env: dict, prefix, src_dict):
  for key, value in src_dict.items():
    if isinstance(value, dict):
      _dict2env(env, prefix + '_' + key.upper(), value)
    else:
      env[prefix + '_' + key.upper()] = str(value)

@click.command()
@click.option('--hosts-file', default='/etc/hosts', help='The hosts file to update.')
@click.option('--once', default=False, help='Run the update script once only.', is_flag=True)
@click.option('--skip-initial', default=False, help="Don't run the update script one time before hooking into the docker event stream.", is_flag=True)
@click.option('--with-command', default=None, help="Run command on trigger event")
@click_log.simple_verbosity_option(logger)
def main(hosts_file: str, skip_initial: bool, once: bool, with_command):
    """Program that automatically updates your `/etc/hosts` file based on your running docker containers."""
    client = docker.from_env()
    if not skip_initial or once:
        if not update_hosts_file(hosts_file):
            logger.error(f'Failed to update hosts in {hosts_file}')
            return -1
        logger.info('Initial update done.')
            
    if once:
        return 0
    
    logger.info('Going to listen for docker events now')
    for event in client.events(decode=True):
        logger.debug(f'Docker event: {event}')

        trigger = _triggering_event(event)
        if not trigger:
            logger.debug(f'Was not a triggering event. Skipping.')
            continue

        logger.info(f'Got triggering event. type={trigger["Type"]} status={trigger["status"]}')
        if not update_hosts_file(hosts_file, trigger_type=trigger["Type"], trigger_status=trigger["status"], with_command=with_command, event=event):
            return -1


if __name__ == "__main__":
    sys.exit(main()) # pylint: disable=E1120
